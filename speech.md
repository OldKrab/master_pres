1. Здравствуйте! Меня зовут... Тема моей работы... Научный руководитель...

2. Данные могут представляться в виде графа и храниться в графовых базах данных. Вершины и ребра в таких графах могут иметь свойства вида ключ-значение, которые можно увидеть у вершин в графе на слайде. 

3. Для доступа к данным в графах обычно используются специальные языки запросов, например, язык Cypher для базы данных Neo4j. Чтобы использовать эти языки из пользовательского кода, мы можем встраивать их как строки. Но данный подход имеет такие недостатки как: отсутствие проверки корректности запроса на этапе компиляции, а также сложность составления и переиспользования подзапросов. Поэтому хочется иметь бесшовную интеграцию запросов к графам в пользовательский язык программирования.

4. Другой способ описать запрос к графу - это извлечь все пути, удовлетворяющие определенным ограничениям. Описать ограничения можно с помощью грамматики, а грамматика в свою очередь удобно описывается с помощью парсер-комбинаторов прямо в языке программирования общего назначения. На слайде приведен пример описания грамматики для извлечения всех питомцев у человека с именем John.

5. Помимо удобной интеграции в язык программирования, мы хотим, чтобы парсер-комбинаторы позволяли описывать контекстно-свободные ограничения. На данный момент существуют использования таких ограничений в области биоинформатики, статического анализа и т.д. Также они должны уметь разбирать циклы в графах, и тут нужно учитывать, что результатов может быть бесконечно много. 

6. На данный момент существует не так много решений с использованием парсер-комбинаторов для запроса к графам. Первых из них это Trails: он имеет экспоненциальную сложность разбора, не поддерживает левую рекурсию, ограниченно поддерживает циклы в графе, но типизация комбинаторов в нем контролирует корректность составленных парсеров. Второй это Meerkat: он работает за полиномиальное время, поддерживает левую рекурсию в грамматике и циклы в графах, но в нем комбинаторы позволяют составлять некорректные парсеры. Оба решения реализованы на языке программирования Scala.

7. Рассмотрим преимущества каждого решения. Meerkat основан на подходах из статьи Practical, General Parser Combinators, которые позволяют поддержать левую рекурсию путем мемоизации результатов парсера, а также добиться поддержки циклов в графе и полиномиальной сложности, генерируя сжатое представление деревьев разбора. Trails в свою очередь имеет удобные комбинаторы, которые контролируют корректность парсеров. В этой работе я попытался объединить преимущества обоих решений.  

8. Исходя из этого, цель моей работы: разработать библиотеку... Задачи: разработать...

9. Для реализации библиотеки я решил использовать язык Kotlin. Базовый тип парсера представляет из себя функцию, принимающую входящее состояние и возвращающую множество выходящих состояний и результатов. В качестве состояния может выступать как вершина, так и ребро графа. Также есть некое стартовое состояние, представляющее весь граф на входе. 
Были реализованы базовые парсеры, которые разбирают примитивные части графа, такие как одна вершина, или ребро. Далее эти парсеры объединяются вместе с помощью комбинаторов, например, последовательно или параллельно. При этом комбинаторы запрещают объединять парсеры с конфликтующими типами состояний, поэтому, например, парсер, принимающий состояние-вершину, не может последовательно объединиться с парсером, возвращающий состояние-ребро.  

10. При наличии левой рекурсии в грамматике разбор будет бесконечно выполняться. Поэтому мы хотим, чтобы любой парсер для каждого входящего состояния выполнялся ровно один раз, даже при наличии рекурсивного вызова. Сделаем так, чтобы парсер в качестве результата возвращал свое вычисление в виде функции, которая принимает в качестве аргумента продолжение, или другими словами callback. Это продолжение будет ждать результатов парсера. Вычисление в свою очередь запоминает все результаты и продолжения, и при появлении нового результата вызывает все сохраненные продолжения. Таким образом, всем продолжениям будут переданы все результаты парсера. 

11. Мемоизация не поможет, если в графе разбирается цикл: тогда будет возвращаться бесконечно много результатов. Поэтому мы представим бесконечное множество разборов в виде конечной структуры, которой является SPPF. Это сжатое представление всех деревьев разбора. Извлечь результаты из SPPF можно с помощью обычного обхода, используя ленивые вычисления. На примере на слайде приведен SPPF для графа петли, представляющий все разборы от вершины x до нее же самой. Обход этой структуры будет возвращать бесконечно много результатов, т.к. в SPPF имеется цикл.

12. Для исследования времени работы была добавлена поддержка базы данных Neo4j. Было взято три набора данных, для первых двух использовался контекстно-свободный запрос, а для третьего использовался регулярный запрос. 

13. На слайде приведены результаты исследования. Первый датасет имеет графы относительно небольшого объема, и на нем мое решение работает быстрее. Второй датасет имеет графы объемом на порядки больше, и на них Meerkat имеет преимущество. В третьем датасете граф имеет десятки миллионов вершин и ребер, и на нем мое решение отрабатывает за конечное время, когда Meerkat падает с OutOfMemory ошибкой. 

14. Результаты: Разработаны...